package classes;

import java.util.ArrayList;

/**
 * @author Alexander J. Cintron Baez
 * @email alexander.cintron1@upr.edu
 * @studentID 802-15-1388 | UPRM
 * @class PyramidScheme: PyramidScheme that contains the members and generates the possible lists of members that can be arrested.
 */
/**
 * @author cintr
 *
 */
public class PyramidScheme {
	
	private ArrayList<Member> members;
	private ArrayList<Jail> jails;
	private int maxAssets;
	
	/**
	 * Constructor for PyramidScheme.
	 * Initializes the members and jails ArrayList.
	 */
	public PyramidScheme() {
		members = new ArrayList<Member>();
		jails = new ArrayList<Jail>();
		maxAssets = 0;
	}
	
	/**
	 * The addMember method adds a new Member to the PyramidScheme.
	 * This method will add a new Member and set their sponsor and mentor, based on the String recieved.
	 * @param m New Member to be added to the PyramidScheme.
	 * @param s String contain the name of the new Member's sponsor. Used to find and set the new Member's sponsor and mentor
	 * @return void
	 */
	public void addMember(Member m, String s) {
		if(!members.isEmpty()) {
			for(Member k : members) {
				if(k.getName().equals(s)) {
					if(!k.getChildren().isEmpty()) {
						m.setMentor(k.getChildren().get(k.getChildren().size()-1));
					} else {
						m.setMentor(k);
					}
					k.addChildren(m);
					m.setSponsor(k);
				}
			}
		}
		members.add(m);	
	}
	
	/**
	 * The arrest method creates a new Jail and iterates over every Member in the members ArrayList to use them as TargetZero.
	 * Calls recArrest with TargetZero, Jail, and Number of Maximum Arrests
	 * @param n Number of maximum arrests possible.
	 * @return jails ArrayList of all Jail objects generated.
	 */
	public ArrayList<Jail> arrest(int n)	{
		Jail j = new Jail();
		for(Member m : members) {
			recArrest(m, j, n);
		}
		return jails;
	}
	
	/**
	 * The recArrest method recursively analizes every possible arrest scenario. 
	 * For every scenario, it will generate a new Jail and add a copy of it to jails ArrayList.
	 * @param m Member, initialy TargetZero, is a revealed Member that will reveal more Members.
	 * @param j Jail contains the ArrayList of arrested member and is copied and added to the jails ArrayList to keep track of possible arrest scenarios.
	 * @param n Maximum number of arrests.
	 */
	private void recArrest(Member m, Jail j, int n) {
		int jSize = j.getArrestedList().size();
		ArrayList<Member> arrested = j.getArrestedList();
		if(jSize < n && m != null && !arrested.contains(m)) {
			j.arrestMember(m);
			recArrest(m.getMentor(), j, n);
			recArrest(m.getSponsor(), j, n);
			if(!m.getChildren().isEmpty()) {
				for(Member k : m.getChildren()) {
					if(!arrested.contains(k))
					recArrest(k, j, n);
				}
			}
			addNewJail(j.copyJail());
			j.releaseMember(m);
		}
	}
	
	/**
	 * The addNewJail method is called everytime a new Jail is generated with a possible arrest scenario.
	 * This method will check that the Jail recieved as parameter does not repeat and that 
	 * the ArrayList jails only contains the Jails with the higher Assets possible, to help 
	 * with efficiency.
	 * @param j copy of a Jail generated by recArrest
	 * @return void
	 */
	private void addNewJail(Jail j) {
		if(jails.isEmpty()) {
			jails.add(j);
			maxAssets = j.getSeizedAssets();
		}else if(greaterAsset(j)) {
			for(Jail c : jails)
				c.clear();
			jails.clear();
			jails.add(j);
			maxAssets = j.getSeizedAssets();
		} else if((!isDuplicate(j)) && equalAsset(j)) {
			jails.add(j);
		}
	}
	
	/**
	 * The greaterAsset method will compare the new Jail with the Jails inside the jails ArrayList.
	 * Assumes all Jails in jails ArrayList have Assets of equal value.
	 * @param j new Jail to be compared
	 * @return true, if the new Jail has greater assets than any Jail in the jails ArrayList; false otherwise.
	 */
	private boolean greaterAsset(Jail j) {
		for(Jail jj : jails) 
			if(j.getSeizedAssets() > jj.getSeizedAssets())
				return true;
		return false;
	}
	
	/**
	 * The equalAsset method will check if the new Jail to be added has assets of equal values to those of the Jails in jails ArrayList.
	 * @param j Jail to be compared
	 * @return false if two compared Jails have different assets; true otherwise.
	 */
	private boolean equalAsset(Jail j) {
		for(Jail jj : jails) 
			if(j.getSeizedAssets() != jj.getSeizedAssets())
				return false;
		return true;
	}
	
	/**
	 * The isDuplicate method will check if the new Jail to be added is a duplicate of any Jail in the jails ArrayList.
	 * @param j Jail to be compared
	 * @return true if duplicate; false otherwise.
	 */
	private boolean isDuplicate(Jail j) {
		for(Jail jj : jails)
			if(jj.getArrestedList().equals(j.getArrestedList()))
				return true;
		return false;
	}
	
	
	/**
	 * The getMaxAssets will return maximum seized assets.
	 * @return maxAssets 
	 */
	public int getMaxAssets() {
		return maxAssets;
	}
	
	/**
	 * The clear method clears the instanced PyramidScheme to help the garbage collector work more efficiently.
	 * @return void
	 */
	public void clear() {
		for(Member m : members) {
			m.clear();
			m = null;
		}
		members.clear();
		for(Jail j : jails) {
			j.clear();
		}
	}
}